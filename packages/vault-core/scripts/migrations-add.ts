#!/usr/bin/env node
/**
 * POC migrations add script - moved to packages/vault-core/scripts
 * Runs relative to CWD and supports copying drizzle migration files if present.
 */

import { promises as fs } from 'node:fs';
import path from 'node:path';

type Args = {
	adapter?: string | undefined;
	tag?: string | undefined;
	sqlId?: string | undefined;
	title?: string | undefined;
	noTransform?: boolean | undefined;
	cwd: string;
};

function printUsage() {
	console.log(
		`
POC: migrations add

Required:
  --adapter, -a   Adapter id (e.g., reddit)
  --tag, -t       4-digit version tag (e.g., 0002)

Optional:
	--sql-id, -s    Override SQL source id when auto-detection is undesirable
  --title         Comment header for migration.sql
  --no-transform  Skip creating versions/<tag>/transform.ts

Examples:
  # Print-only (recommended): generates migration.sql and prints a ready-to-paste block
  node packages/vault-core/scripts/migrations-add.poc.ts -a reddit -t 0002 -s 0002_forward_baseline
`.trim(),
	);
}

function parseArgs(argv: string[], cwd: string): Args {
	const args: Args = { cwd };
	const rest = [...argv];
	for (let i = 0; i < rest.length; i++) {
		const cur = rest[i];
		if (cur === undefined) throw new Error('unexpected undefined arg');

		if (cur === '--adapter' || cur === '-a') {
			args.adapter = rest[i + 1];
			i++;
		} else if (cur.startsWith('--adapter=')) {
			args.adapter = cur.split('=')[1];
		} else if (cur === '--tag' || cur === '-t') {
			args.tag = rest[i + 1];
			i++;
		} else if (cur.startsWith('--tag=')) {
			args.tag = cur.split('=')[1];
		} else if (cur === '--sql-id' || cur === '-s') {
			args.sqlId = rest[i + 1];
			i++;
		} else if (cur.startsWith('--sql-id=')) {
			args.sqlId = cur.split('=')[1];
		} else if (cur === '--title') {
			args.title = rest[i + 1];
			i++;
		} else if (cur.startsWith('--title=')) {
			args.title = cur.split('=')[1];
		} else if (cur === '--no-transform') {
			args.noTransform = true;
		} else {
			// ignore unknown args for POC
		}
	}
	return args;
}

function assertValid(args: Args) {
	const errors: string[] = [];
	if (!args.adapter) errors.push('missing --adapter');
	if (!args.tag) errors.push('missing --tag');

	const tag = args.tag ?? '';
	const sqlId = args.sqlId ?? '';

	if (!/^\d{4}$/.test(tag)) {
		errors.push(`invalid tag '${tag}', expected 4 digits like 0002`);
	}
	if (sqlId && !/^[A-Za-z0-9_-]+$/.test(sqlId)) {
		errors.push(
			`invalid sql-id '${sqlId}', allowed [A-Za-z0-9_\\-], e.g. 0002_add_foo`,
		);
	}

	if (errors.length) {
		for (const e of errors) console.error('•', e);
		console.error();
		printUsage();
		process.exit(1);
	}
}

async function pathExists(p: string) {
	try {
		await fs.access(p);
		return true;
	} catch {
		return false;
	}
}

async function ensureDir(p: string) {
	await fs.mkdir(p, { recursive: true });
}

async function writeFileIfAbsent(p: string, content: string) {
	if (await pathExists(p)) return false;
	await fs.writeFile(p, content, 'utf8');
	return true;
}

function sqlHeader(
	adapter: string,
	tag: string,
	sqlId: string,
	title?: string,
) {
	const lines = [
		`-- adapter: ${adapter}`,
		`-- tag: ${tag}`,
		`-- sqlId: ${sqlId}`,
		...(title ? [`-- title: ${title}`] : []),
		'--',
		'-- Forward-only migration generated by POC scaffolder.',
		'-- Add your DDL statements below.',
		'',
	];
	return lines.join('\n');
}

function transformStub(tag: string) {
	return `import type { DataTransform } from '../../../core/migrations';

export const transform_${tag}: DataTransform = async (input) => {
  // TODO: transform data from previous version to ${tag}
  return input;
};
`;
}

/**
 * Split SQL text into executable statements.
 * Mirrors core split logic (drizzle '--> statement-breakpoint' or semicolons).
 */
function splitSqlText(text: string): string[] {
	if (text.includes('--> statement-breakpoint')) {
		return text
			.split(/-->\s*statement-breakpoint\s*/g)
			.map((s) => s.trim())
			.filter((s) => s.length > 0);
	}
	return text
		.split(/;\s*(?:\r?\n|$)/g)
		.map((s) => s.trim())
		.filter((s) => s.length > 0)
		.map((s) => (s.endsWith(';') ? s : `${s};`));
}

/**
 * Format a versions.ts entry block for copy-paste into an adapter's versions tuple.
 * Mirrors the style used in existing adapters (backticked SQL strings, indented).
 */
function formatVersionBlock(tag: string, sqlStatements: string[]): string {
	const body = sqlStatements
		.map((stmt) => {
			// escape backticks and indent multi-line for readability
			const escaped = stmt.replace(/`/g, '\\`').replace(/\r?\n/g, '\n\t\t\t');
			return `\t\t\t\`${escaped}\``;
		})
		.join(',\n');

	return [
		'\t{',
		`\t\ttag: '${tag}',`,
		'\t\t// Generated by migrations-add script',
		'\t\tsql: [',
		body,
		'\t\t],',
		'\t},',
	].join('\n');
}

/**
 * Append a new version object to the adapter's migrations/versions.ts defineVersions() tuple,
 * embedding the provided SQL statements inline.
 */
/**
 * Try to copy drizzle-produced migration files from common locations under cwd.
 * This is a best-effort convenience: hosts may produce drizzle migration outputs in different places.
 */
async function copyDrizzleMigrationFiles(
	cwd: string,
	tag: string,
	destDir: string,
	sqlPath: string,
) {
	const candidates = [
		'migrations',
		'drizzle/migrations',
		'migrations/drizzle',
		'drizzle',
	];
	for (const c of candidates) {
		const full = path.join(cwd, c);
		if (!(await pathExists(full))) continue;
		const files = await fs.readdir(full);
		const matched: string[] = [];
		for (const f of files) {
			if (f.includes(tag)) matched.push(f);
		}
		if (matched.length === 0) return;

		for (const f of matched) {
			const src = path.join(full, f);
			const dst = path.join(destDir, f);
			try {
				await fs.copyFile(src, dst);
				console.log(`  ✓ copied drizzle file ${src} -> ${dst}`);
			} catch (err) {
				console.warn(`  ! failed copying ${src} -> ${dst}: ${err}`);
			}

			// If .sql, append its contents into migration.sql
			if (path.extname(f).toLowerCase() === '.sql') {
				try {
					const sqlText = await fs.readFile(src, 'utf8');
					await fs.appendFile(
						sqlPath,
						`\n-- == Imported from ${src} ==\n${sqlText}\n`,
					);
					console.log(`  ✓ appended SQL from ${src} into ${sqlPath}`);
				} catch (err) {
					console.warn(
						`  ! failed appending SQL from ${src} into ${sqlPath}: ${err}`,
					);
				}
			}
		}

		return;
	}
}

async function main() {
	const argv = process.argv.slice(2);
	if (argv.length === 0 || argv.includes('--help') || argv.includes('-h')) {
		printUsage();
		process.exit(0);
	}

	const args = parseArgs(argv, process.cwd());
	assertValid(args);

	const adapter = args.adapter as string;
	const tag = args.tag as string;
	let sqlId = args.sqlId;
	const title = args.title;

	// Resolve key paths (operate on CWD)
	const root = args.cwd;
	const adapterDir = path.join(
		root,
		'packages',
		'vault-core',
		'src',
		'adapters',
		adapter,
	);
	const versionsFilePath = path.join(adapterDir, 'migrations', 'versions.ts');
	const versionsDir = path.join(adapterDir, 'migrations', 'versions', tag);
	const sqlPath = path.join(versionsDir, 'migration.sql');
	const transformPath = path.join(versionsDir, 'transform.ts');
	const migrationsDir = path.join(adapterDir, 'migrations');

	// Validate adapter and manifest presence
	if (!(await pathExists(adapterDir))) {
		console.error(`❌ adapter directory not found: ${adapterDir}`);
		process.exit(1);
	}
	if (!(await pathExists(versionsFilePath))) {
		console.error(
			`❌ versions.ts not found for adapter '${adapter}': ${versionsFilePath}`,
		);
		process.exit(1);
	}

	let sqlSourcePath: string | undefined;
	if (!sqlId) {
		if (await pathExists(migrationsDir)) {
			const files = await fs.readdir(migrationsDir);
			const matches = files.filter(
				(f) => f.startsWith(`${tag}_`) && f.toLowerCase().endsWith('.sql'),
			);
			if (matches.length === 1) {
				const match = matches[0];
				if (match === undefined) throw new Error('unexpected undefined match');

				sqlId = path.parse(match).name;
				sqlSourcePath = path.join(migrationsDir, match);
				console.log(
					`  ✓ detected sql-id '${sqlId}' from ${path.relative(root, sqlSourcePath)}`,
				);
			} else if (matches.length > 1) {
				console.error(
					`❌ multiple SQL files matched tag '${tag}'. Provide --sql-id to disambiguate:`,
				);
				for (const match of matches) {
					console.error(
						`    ${path.relative(root, path.join(migrationsDir, match))}`,
					);
				}
				process.exit(1);
			}
		}
		if (!sqlId) {
			console.error(
				`❌ unable to detect SQL source for tag '${tag}'. Provide --sql-id explicitly.`,
			);
			process.exit(1);
		}
	} else {
		const candidate = path.join(migrationsDir, `${sqlId}.sql`);
		if (await pathExists(candidate)) {
			sqlSourcePath = candidate;
		}
	}

	const resolvedSqlId = sqlId;
	if (!resolvedSqlId) {
		throw new Error('failed to resolve sqlId after detection');
	}

	// Create dirs and files
	await ensureDir(versionsDir);

	const sqlCreated = await writeFileIfAbsent(
		sqlPath,
		`${sqlHeader(adapter, tag, resolvedSqlId, title)}`,
	);
	if (sqlCreated) {
		console.log(`  ✓ created ${sqlPath}`);
	} else {
		console.log(`  • exists ${sqlPath}`);
	}

	if (sqlCreated && sqlSourcePath) {
		const sqlText = await fs.readFile(sqlSourcePath, 'utf8');
		const normalized = sqlText.endsWith('\n') ? sqlText : `${sqlText}\n`;
		await fs.appendFile(
			sqlPath,
			`\n-- == Imported from ${path.relative(root, sqlSourcePath)} ==\n${normalized}`,
		);
		console.log(
			`  ✓ copied ${path.relative(root, sqlSourcePath)} into ${sqlPath}`,
		);
	} else if (sqlCreated && !sqlSourcePath) {
		console.log(
			`  • no existing SQL artifact found for tag '${tag}' in ${path.relative(root, migrationsDir)}`,
		);
	}

	if (!args.noTransform) {
		const tCreated = await writeFileIfAbsent(transformPath, transformStub(tag));
		if (tCreated) {
			console.log(`  ✓ created ${transformPath}`);
		} else {
			console.log(`  • exists ${transformPath}`);
		}
	} else {
		console.log('  • skipped transform stub (--no-transform)');
	}

	// Try to copy drizzle migration files (best-effort) and append .sql to migration.sql
	await copyDrizzleMigrationFiles(root, tag, versionsDir, sqlPath);

	// Read migration.sql, split into statements
	const finalSqlText = await fs.readFile(sqlPath, 'utf8');
	console.log(sqlPath);
	const statements = splitSqlText(finalSqlText);

	// Always print a ready-to-paste block for developer convenience
	console.log(
		'\n--- Copy & paste into your adapter migrations/versions.ts ---\n',
	);
	console.log(formatVersionBlock(tag, statements));
	console.log('\n--- end block ---\n');

	// Script operates in print-only mode; developer must manually update migrations/versions.ts
	console.log(
		'Print-only mode (no file edits). Manually update migrations/versions.ts with the block above.',
	);

	console.log('\nDone.');
}

main().catch((err) => {
	console.error('❌ Error:', err?.message ?? err);
	process.exit(1);
});
