# FFmpeg Recording Stop Fix - Root Cause Analysis & Solution

## Date
2025-11-14

## Problem Statement
Windows users experience recording stop failures where the output file doesn't exist after stopping. The UI shows "Stopping" → "Loading" → "Stopping" → "Failed", and the error indicates the file was never created/finalized.

## Root Cause Analysis

### Critical Bug #1: Missing stdin Configuration in Rust spawn_command

**Location**: `apps/whispering/src-tauri/src/command.rs:129-137`

The `spawn_command` function spawns FFmpeg without configuring stdin:

```rust
let mut cmd = Command::new(&program);
cmd.args(&args);

#[cfg(target_os = "windows")]
{
    cmd.creation_flags(CREATE_NO_WINDOW);
}

match cmd.spawn() {
    Ok(child) => {
        let pid = child.id();
        // ...
    }
}
```

**The problem**: No `.stdin(Stdio::piped())` is configured, so FFmpeg has no stdin handle.

**Impact**: When TypeScript calls `activeChild.write('q\n')` on line 372 of `ffmpeg.ts`, the write fails silently (caught by `tryAsync`). FFmpeg never receives the graceful quit command.

### Critical Bug #2: Broken Backup Kill Mechanism

**Location**: `apps/whispering/src/lib/services/recorder/ffmpeg.ts:357-404`

```typescript
const scheduleBackupKill = (delayMs: number) => {
    setTimeout(() => {
        activeChild?.kill().catch(() => {});  // activeChild is captured here
    }, delayMs);
};

// ... send signals ...
scheduleBackupKill(5000);  // Schedule backup kill

const outputPath = activeOutputPath;

// Clear state IMMEDIATELY after scheduling
activeChild = null;           // ← BUG: This nullifies the backup kill!
activeOutputPath = null;
```

**The problem**: The closure in `scheduleBackupKill` captures `activeChild`, but the state is immediately cleared on line 403. When the 5-second timeout fires, `activeChild?.kill()` does nothing because `activeChild` is null.

**Impact**: The backup kill never executes, leaving FFmpeg running indefinitely if the quit signals fail.

### Critical Bug #3: Windows SIGINT with CREATE_NO_WINDOW

**Location**: `apps/whispering/src-tauri/src/graceful_shutdown.rs:32-52`

```rust
#[cfg(windows)]
{
    use windows_sys::Win32::System::Console::{GenerateConsoleCtrlEvent, CTRL_C_EVENT};

    unsafe {
        let result = GenerateConsoleCtrlEvent(CTRL_C_EVENT, pid);
        // ...
    }
}
```

**The problem**: `GenerateConsoleCtrlEvent` requires the target process to be attached to a console session. However, processes spawned with `CREATE_NO_WINDOW` flag (line 135 in `command.rs`) may not be in the same console group, causing the Ctrl+C event to fail.

**Impact**: The SIGINT fallback mechanism doesn't work, leaving only the broken backup kill as the last resort.

## Why The File Doesn't Exist

The sequence of failures:

1. **stdin 'q' fails** → FFmpeg doesn't receive quit command
2. **SIGINT fails** → FFmpeg doesn't receive Ctrl+C
3. **Backup kill fails** → FFmpeg continues running
4. **File polling times out** → File doesn't exist because FFmpeg never finalized it
5. **Error returned** → User sees "file not found"

FFmpeg needs to receive a proper shutdown signal to:
- Flush audio buffers
- Write WAV file headers
- Close file handles
- Exit gracefully

Without any of these signals reaching FFmpeg, the file remains incomplete or non-existent.

## Solution Proposal

### Fix #1: Add stdin Piping to spawn_command (Rust)

**File**: `apps/whispering/src-tauri/src/command.rs`

**Change**: Configure stdin for spawned processes:

```rust
#[tauri::command]
pub async fn spawn_command(command: String) -> Result<u32, String> {
    let (program, args) = parse_command(&command);

    if program.is_empty() {
        return Err("Empty command".to_string());
    }

    println!("[Rust] spawn_command: program='{}', args={:?}", program, args);

    let mut cmd = Command::new(&program);
    cmd.args(&args);
    cmd.stdin(Stdio::piped());  // ← ADD THIS LINE

    #[cfg(target_os = "windows")]
    {
        cmd.creation_flags(CREATE_NO_WINDOW);
        println!("[Rust] spawn_command: Windows - using CREATE_NO_WINDOW flag");
    }

    match cmd.spawn() {
        // ... rest unchanged
    }
}
```

### Fix #2: Preserve Child Reference for Backup Kill (TypeScript)

**File**: `apps/whispering/src/lib/services/recorder/ffmpeg.ts`

**Change**: Capture the child reference in the closure instead of relying on `activeChild`:

```typescript
stopRecording: async ({
    sendStatus,
}): Promise<Result<Blob, RecorderServiceError>> => {
    if (!activeChild || !activeOutputPath) {
        return RecorderServiceErr({
            message: 'No active recording to stop',
            cause: undefined,
        });
    }

    sendStatus({
        title: '⏹️ Stopping',
        description: 'Stopping FFmpeg recording...',
    });

    // Capture references that won't be nullified
    const childToKill = activeChild;
    const outputPath = activeOutputPath;

    // Helper: Schedule backup force kill with captured reference
    const scheduleBackupKill = (delayMs: number) => {
        setTimeout(() => {
            childToKill.kill().catch(() => {
                // Expected: process may have already exited gracefully
            });
        }, delayMs);
    };

    // Stop FFmpeg gracefully
    const { error: stopError } = await tryAsync({
        try: async () => {
            // Try stdin 'q' first (most reliable, especially on Windows)
            await tryAsync({
                try: async () => {
                    await activeChild.write('q\n');
                    // Give FFmpeg time to process the quit command
                    await new Promise((resolve) => setTimeout(resolve, 1000));
                },
                catch: () => Ok(undefined), // stdin might not be available, continue
            });

            // Also send SIGINT as backup
            await sendSigint(activeChild.pid);

            // Schedule force kill with longer timeout to give FFmpeg time to finalize
            scheduleBackupKill(5000);
        },
        catch: (error) =>
            RecorderServiceErr({
                message: `Failed to stop FFmpeg process: ${extractErrorMessage(error)}`,
                cause: error,
            }),
    });

    if (stopError) {
        sendStatus({
            title: '❌ Error Stopping Recording',
            description:
                "We couldn't stop the recording properly. Attempting to recover your audio...",
        });
    }

    // Clear state AFTER capturing references
    activeChild = null;
    activeOutputPath = null;

    // Poll for file stabilization
    // ... rest of the polling logic unchanged ...
}
```

### Fix #3: Replace GenerateConsoleCtrlEvent with TerminateProcess

**File**: `apps/whispering/src-tauri/src/graceful_shutdown.rs`

**Problem**: `GenerateConsoleCtrlEvent` requires the target process to be attached to a console session. Processes spawned with `CREATE_NO_WINDOW` flag are not attached to a console, so the Ctrl+C event cannot reach them.

**Solution**: Replace `GenerateConsoleCtrlEvent` with `TerminateProcess` for Windows.

```rust
#[cfg(windows)]
{
    // Windows: Use TerminateProcess for forceful shutdown
    // Note: GenerateConsoleCtrlEvent doesn't work with CREATE_NO_WINDOW processes
    // since they're not attached to a console session. TerminateProcess is more
    // reliable for processes spawned without a console.
    use windows_sys::Win32::System::Threading::{OpenProcess, TerminateProcess, PROCESS_TERMINATE};
    use windows_sys::Win32::Foundation::CloseHandle;

    unsafe {
        let process_handle = OpenProcess(PROCESS_TERMINATE, 0, pid);

        if process_handle == 0 {
            return SignalResult {
                success: false,
                message: format!("Failed to open process {}", pid),
            };
        }

        let result = TerminateProcess(process_handle, 1);
        CloseHandle(process_handle);

        if result != 0 {
            SignalResult {
                success: true,
                message: format!("Process {} terminated", pid),
            }
        } else {
            SignalResult {
                success: false,
                message: format!("Failed to terminate process {}", pid),
            }
        }
    }
}
```

**Trade-off**: `TerminateProcess` is forceful (not graceful like SIGINT), but:
1. stdin 'q' (Fix #1) provides the graceful shutdown mechanism
2. `GenerateConsoleCtrlEvent` doesn't work anyway with `CREATE_NO_WINDOW`
3. This makes `send_sigint` actually functional on Windows
4. The backup kill still provides redundancy if `TerminateProcess` fails

## Testing Plan

### Test Case 1: Normal Stop (Happy Path)
- Start recording on Windows
- Stop recording after 5+ seconds
- Verify: File exists, has non-zero size, can be opened
- Expected: stdin 'q' succeeds, FFmpeg finalizes file within 2 seconds

### Test Case 2: Stdin Failure Fallback
- Modify code to force stdin failure
- Start and stop recording
- Verify: Backup kill executes, file still created
- Expected: SIGINT or backup kill terminates FFmpeg, file saved

### Test Case 3: Long Recording
- Record for 60+ seconds
- Stop recording
- Verify: Large file created and stable
- Expected: stdin 'q' works, file finalized properly

### Test Case 4: Rapid Start/Stop
- Start recording, immediately stop (< 1 second)
- Verify: Either file created or clean error
- Expected: Process stops, no orphaned FFmpeg

## Implementation Checklist

- [x] Add `cmd.stdin(Stdio::piped())` to `spawn_command` in command.rs
- [x] Update `scheduleBackupKill` to capture child reference in ffmpeg.ts
- [x] Move `activeChild = null` assignment after backup kill scheduling
- [x] Replace `GenerateConsoleCtrlEvent` with `TerminateProcess` on Windows
- [ ] Test on Windows with various recording lengths
- [ ] Test stdin 'q' by adding debug logging
- [ ] Verify backup kill executes when stdin fails
- [ ] Verify TerminateProcess works reliably

## Expected Outcome

With these fixes:
1. **stdin 'q' will work** because FFmpeg has a proper stdin pipe
2. **Backup kill will work** because it captures the child reference before nullification
3. **Files will be finalized** because FFmpeg receives proper shutdown signals
4. **Fallback works** even if stdin fails, backup kill provides safety net

## Additional Notes

### Why CREATE_NO_WINDOW is Required
From GitHub issue #815: Prevents console window flash on Windows. We can't remove this flag as it's a critical UX issue.

### Why stdin 'q' is Preferred Over SIGINT
FFmpeg documentation states that 'q' typed at stdin is the official way to gracefully stop recording. SIGINT works on Unix but is unreliable on Windows with console-less processes.

### Why Backup Kill is Critical
Even with stdin configured, there are edge cases where the write could fail (process already dead, pipe broken). The backup kill provides a guaranteed cleanup mechanism.

## Review

### Changes Summary
1. **Rust command.rs**: Add stdin piping to spawned processes
2. **TypeScript ffmpeg.ts**: Capture child reference before nullification in backup kill closure

### Impact Assessment
- **Risk**: Low - changes are minimal and well-scoped
- **Testing**: Required on Windows to verify stdin 'q' works
- **Backward Compatibility**: No breaking changes
- **Performance**: No impact

### Alternative Considered: Wait for Process Exit
Instead of immediately clearing state, we could wait for FFmpeg to exit before polling the file. However, this adds complexity and timeout management. The current approach with fixed references is simpler and equally effective.
